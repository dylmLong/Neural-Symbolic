"""
Execution Agent

According to the paper: The execution agent obtains program results and adaptively dispatches programs from each domain to underlying heterogeneous hardware.

Responsibilities:
- Execute code/instructions generated by Coding Agent
- Select and execute execution operators from operator pool
- Dispatch tasks to appropriate hardware (GPU, CPU, etc.)
- Schedule execution flow (SQL routing, etc.)

Interface separation: Execution Agent is only responsible for execution, not code generation. Code is generated by Coding Agent.
"""
from agent.shared.state import AgentState, ExecutionInstruction
from operators import OPERATOR_REGISTRY

# Select operators from operator pool
from operators.perception.yolo_detector import detect_objects  # Select from operator pool: perception operator
from operators.execution.sql_executor import execute_sql_query  # Select from operator pool: execution operator
from operators.coordination.sql_router import sql_router_step, route_sql_condition  # Select from operator pool: SQL routing operator
from operators.coordination.result_filter import filter_result_operator  # Select from operator pool: result filtering operator
from operators.coordination.chat_responder import chat_responder_operator  # Select from operator pool: chat response operator


class ExecutionAgent:
    """
    Execution Agent: Executes code/instructions generated by Coding Agent.
    
    According to the paper, the execution agent's responsibilities are:
    - Obtain program results
    - Adaptively dispatch programs from each domain to underlying heterogeneous hardware
    - Schedule execution to improve efficiency
    - Receive real-time feedback simultaneously
    
    Interface separation principle:
    - Execution Agent is only responsible for execution, not code generation
    - Code/instructions are generated by Coding Agent
    - Execution Agent calls corresponding operators based on instructions
    
    Current operators selected from operator pool:
    - operators.perception.yolo_detector.detect_objects (perception operator)
    - operators.execution.sql_executor.execute_sql_query (execution operator)
    - operators.coordination.sql_router (SQL routing operator)
    - operators.coordination.result_filter (result filtering operator)
    - operators.coordination.chat_responder (chat response operator)
    
    Note: Intent classification and routing belong to Decomposition Agent, not Execution Agent.
    """

    def __init__(self):
        # Operator registry (UOP - Unified Operator Pool)
        self.operator_registry = OPERATOR_REGISTRY
        # Operator categories available to current Agent
        self.available_categories = ["perception", "execution", "coordination"]
        
        # Operator mapping table: maps operator names in instructions to actual operator functions
        self.operator_map = {
            "yolo_detector": detect_objects,
            "sql_executor": execute_sql_query,
        }

    def execute_perception(self, state: AgentState) -> AgentState:
        """
        Execute perception instruction: Execute YOLO detection based on instruction generated by Coding Agent
        
        Interface separation: Execution Agent executes instructions generated by Coding Agent, does not generate code.
        """
        instruction: ExecutionInstruction = state.get("perception_instruction")
        if not instruction:
            raise ValueError("Perception call instruction not found, cannot execute detection")
        
        operator_name = instruction["operator"]
        params = instruction["params"]
        
        if operator_name not in self.operator_map:
            raise ValueError(f"Unknown operator name: {operator_name}")
        
        print("\n================================[PerceptionExecutionAgent]=================================\n")
        print(f"PerceptionExecutionAgent called perception execution function:")
        print(f"Executing operator: {operator_name}")
        print(f"Execution parameters: {params}")
        
        # Call corresponding operator based on instruction
        operator_func = self.operator_map[operator_name]
        objects = operator_func(**params)  # Execute operator
        
        print(f"Perception execution completed, detected {len(objects)} objects:")
        for i, obj in enumerate(objects, 1):
            print(f"[{i}] Label: {obj.get('label')} | Confidence: {obj.get('confidence'):.2f} | Location: {obj.get('bbox')}")
        
        new_state = state.copy()
        new_state["objects"] = objects  # Set new state with detected objects
        return new_state  # Return new Agent state

    def execute_sql(self, state: AgentState) -> AgentState:
        """
        Call execution operator: SQL query execution
        
        Select from operator pool: operators.execution.sql_executor.execute_sql_query
        
        Interface separation: Execution Agent executes SQL generated by Coding Agent, does not generate SQL.
        """
        executed = set(state.get("executed_sqls") or [])  # Already executed SQLs
        sql = state.get("current_sql")  # Currently executing SQL
        index = str(state.get("current_index"))  # Index of currently executing SQL
        if not sql:
            print("No SQL to execute")
            return state
        print("\n================================[SqlExecutionAgent]=================================\n")
        print(f"SqlExecutionAgent called SQL execution function:")
        print(f"Executing SQL[{index}]: {sql}")
        # Call execution operator from operator pool
        result = execute_sql_query(sql)  # Single SQL statement execution result
        if len(result) == 0:
            print(f"SQL execution result: [] (empty result)\n")
        else:  # If not empty, print execution result
            print(f"SQL execution result: {len(result)} records\n")
            print("[")
            for row in result:
                print(f"\t{row}")
            print("]")
        new_state = state.copy()  # Set new state, update executed statements and query results, return state
        executed_sqls = list(executed | {sql})
        new_state["executed_sqls"] = executed_sqls
        query_results = (state.get("query_results") or []) + [result]
        new_state["query_results"] = query_results
        return new_state

    def sql_router_step(self, state: AgentState) -> AgentState:
        """
        Call SQL routing operator: Select next SQL to execute
        
        Select from operator pool: operators.coordination.sql_router.sql_router_step
        """
        return sql_router_step(state)

    def route_sql(self, state: AgentState) -> str:
        """
        Call SQL routing condition operator: Determine if there are more SQLs to execute
        
        Select from operator pool: operators.coordination.sql_router.route_sql_condition
        """
        return route_sql_condition(state)

    def filter_result(self, state: AgentState) -> AgentState:
        """
        Call result filtering operator: Filter out SQLs with empty query results
        
        Select from operator pool: operators.coordination.result_filter.filter_result_operator
        """
        return filter_result_operator(state)

    def chat(self, state: AgentState) -> AgentState:
        """
        Call chat response operator: Use LLM to respond to user
        
        Select from operator pool: operators.coordination.chat_responder.chat_responder_operator
        """
        return chat_responder_operator(state)

